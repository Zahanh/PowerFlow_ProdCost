"""
TIGHT FORMULATION
    OBJECTIVE           (69)
    UP TIME/DOWN TIME   (2,3,4,5)
    GEN LIMITS          (17,23,38,40*,41)
    RAMP LIMITS         (35,36)
    PIECEWISE PROD      (43,44,46** OR 48)
    START UP COSTS      (59,60,61)
    SHUT DOWN COSTS     (62)
    SYSTEM CONSTRAINTS  (64,65,66,67)

VARS:
    ug, vg, wg, xg, p'g, _p'g, pw,fk, theta_n, sn+, sn-, sn, sR
"""
import pulp as lp
import pandas as pd
import numpy as np
import random
import matplotlib.pyplot as plt
import os,json,math

print(lp.listSolvers(onlyAvailable=True))
solver = lp.getSolver('SCIP_PY')

"""
NOTE: CHANGES MADE FROM THE PAPER...

- We want to use p(t) as the percentage of power (int from 0-100) of the nameplate maximum power. 
- Assumption of no reserves at the moment. 
- WE CANNOT DIVIDE A LP variable...idk why but we multiply the LP var by 0.01 to reduce it by 100 and give it the ability to change between 0-100
"""
# =================================== INPUTS
TIME        = 24
ACCURACY    = 100   # MUST BE ATLEAST 1
# ==========================================
DB_PATH = os.path.join(os.path.dirname(__file__),'DB')
#GENERATORS      = pd.read_parquet('Generator_Database.parquet')
GENERATORS      = pd.read_csv(os.path.join(DB_PATH,'Generator_Database.csv'))
PLANT_STATES    = GENERATORS['Plant State'].unique().tolist() # This will be the basis of a general zonal model.
FUELS           = pd.read_csv(os.path.join(DB_PATH,'Fuels.csv'),index_col='Fuel Name')
HOURLY_DEMAND   = pd.Series(data=[random.randint(13000,25000) for i in range(TIME)])
#demand                      = pd.read_csv('systemload.csv',on_bad_lines='skip')
#HOURLY_DEMAND:pd.Series     = demand[demand['Type'] == 'actual']['Mw']

#NETWORK = pd.read_csv(os.path.join(DB_PATH,'Network.csv'))
model           = lp.LpProblem('UnitCommitment',lp.LpMinimize)

# Creating a dict utilizing the indexes of the generators being the unique id's
GEN_UNITS       = lp.LpVariable.dicts('gens',[f'{i}_{t}' for i in GENERATORS.index.tolist() for t in range(len(HOURLY_DEMAND))],0,ACCURACY,lp.LpInteger)  

# ==================================== State transition variables.
# Creating a dict holding the state variables for state transitions. 
print('adding u')
U   = lp.LpVariable.dicts('U',[f'{i}_{t}' for i in GENERATORS.index.tolist() for t in range(len(HOURLY_DEMAND))],0,1,lp.LpBinary)
print('adding v')
V   = lp.LpVariable.dicts('V',[f'{i}_{t}' for i in GENERATORS.index.tolist() for t in range(len(HOURLY_DEMAND))],0,1,lp.LpBinary)
print('adding w')
W   = lp.LpVariable.dicts('W',[f'{i}_{t}' for i in GENERATORS.index.tolist() for t in range(len(HOURLY_DEMAND))],0,1,lp.LpBinary)

def line_susceptance(X:float) -> float:
    """
    Returns the line susceptance (Bd)
    """
    return 1/X

def voltage_angle(X:float,R:float) -> float:
    """
    Returns the voltage angle given the line reactance and the resistance
    """
    return math.atan(X/R)

# NOTE: Adding the objective function to the LP solver.
def get_power_eq(p_apt_var:lp.LpVariable,min_generation:int,u:lp.LpVariable):
    return p_apt_var + (min_generation * u)

def p_apt(gen_id:int,time:int):
    """ Representing p'(t)\n
     Power generated above minimum by generator g at time t (MW), ≥ 0 """
    
    return (p(gen_id,time)- GENERATORS.iloc[gen_id]['Minimum Capacity (MW)'])

def _p_apt(gen_id:int,time:int):
    """
    Maximum power available above minimum from generator g at time t (MW), ≥ 0.
    """

    # min_gen = GENERATORS.iloc[gen_id]['Minimum Capacity (MW)']
    # max_gen = GENERATORS.iloc[gen_id]['Nameplate Capacity (MW)']
    
    # NOTE: 0 Used to represent the reserve market
    return p_apt(gen_id,time) + 0
# GOOD
def _p(gen_id:int,time:int):
    """
    _pg(t)\n 
    - Maximum power available from generator g at time t (MW), ≥ 0.

    \n = (pg(t) - P_g) + (P_g*ug(t)) + r_g(t)

    """
    id      = f'{gen_id}_{time}'
    _P_g    = GENERATORS.iloc[gen_id]['Nameplate Capacity (MW)']
    P_g     = GENERATORS.iloc[gen_id]['Minimum Capacity (MW)']

    # NOTE: 0 is meant to denote the reserve amount
    return (p(gen_id,time) - P_g) + P_g*U[id] + 0
# GOOD
def p(gen_id:int, time:int):
    """
    pg(t)\n
    - Power generated by generator g at time t, >=0
    """
    id      = f'{gen_id}_{time}'
    nameplate = GENERATORS.iloc[gen_id]['Nameplate Capacity (MW)']

    return ((GEN_UNITS[id] * ACCURACY**(-1)) * nameplate)

def objective_fcn(gen_index,time:int):
    """
    We want to minimize the :
        - Cost of generation subject to the production cost, startup costs, shut down costs, penalty costs 

    min SUM_all_t (SUM_all_gens (c_g^p(t) + C_g^R*ug(t) + c_g^SU(t) + c_g^SD(t)) + SUM_all_busses(C_LP * (s_n^+(t) + s_n^-(t)) + C_RP * s_R(t)))
    

    RETURNS:
        cost of generation ($/MWh)
    """
    sub_df  = GENERATORS.iloc[gen_index]
    hr      = sub_df['Heat Rate (MMBtu/MWh)']
    su_c    = sub_df['Start Up Costs ($/MW)']
    sd_c    = sub_df['Shut Down Costs ($/MW)']
    fuel    = sub_df['Energy Source Code']
    min_gen = sub_df['Minimum Capacity (MW)']
    id      = f'{gen_index}_{time}'

    return (FUELS.loc[fuel].values[0] * hr * p(gen_index,time)) + (U[id] * min_gen)+ su_c + sd_c
# ================== Objective Function
obj = 0
for time in range(len(HOURLY_DEMAND)):
    print(f'Current hour: {time=}')
    for gen in GENERATORS.index.tolist():
        id = f'{gen}_{time}'
        obj += objective_fcn(gen,time)

        max_limit = GENERATORS.iloc[gen]['Nameplate Capacity (MW)']
        min_limit = GENERATORS.iloc[gen]['Minimum Capacity (MW)']
        model += min_limit * U[id] <= p(gen,time) <= max_limit* U[id], f'Gen_limits_{gen}_{time}'

        # ================== State Variable Restriction
        if time > 0:
            id_min_1 = f'{gen}_{time-1}'
            model += U[id] - U[id_min_1] == V[id] - W[id]   # equation 2
            
            # ================== Adding Ramping Limits (EQ 26,27)
            id2 = f'{gen}_{time+1}'
            RU  = GENERATORS.iloc[gen]['Ramp Up Rate (MW/h)']
            RD  = GENERATORS.iloc[gen]['Ramp Down Rate (MW/h)']
            MAX = GENERATORS.iloc[gen]['Nameplate Capacity (MW)']
            MIN = GENERATORS.iloc[gen]['Minimum Capacity (MW)']
            SD  = GENERATORS.iloc[gen]['Shut Down Rate (MW/h)']    # really MW/h

            # Equations 24 & 25 assuming no SU = RU
            model += (p_apt(gen,time) - p_apt(gen,time-1)) <= RU, f'ramp_up_{id}'
            model += (p_apt(gen,time-1) - p_apt(gen,time)) <= RD, f'ramp_down_{id}'
        
        if time < len(HOURLY_DEMAND)-1:
            id2 = f'{gen}_{time+1}'
            MAX = GENERATORS.iloc[gen]['Nameplate Capacity (MW)']
            SD  = GENERATORS.iloc[gen]['Shut Down Rate (MW/h)']    # really MW/h
            
            # Equation 19
            model += (p(gen,time) <= MAX*(U[id] - W[id2]) + SD*W[id2])

model += obj, 'Objective Function'
print('Added Objective Function')

# ================== Supply >= Demand
print('Adding Supply/demand')
for time in range(len(HOURLY_DEMAND)):    
    demand = HOURLY_DEMAND[time]
    model += lp.lpSum([p(gen_id,time) for gen_id in GENERATORS.index.tolist()]) >= demand, f'Supply>demand_{time}'
    

# print('Adding Network Constraints')
# for time in range(len(HOURLY_DEMAND)):
#     for gen in GENERATORS.index.tolist():

#         id = f'{gen}_{time}'
#         for bus in range(NETWORK['Name'].tolist()):
#             pass





def run(save:bool = True) -> None:
    if save:
        model.writeLP('uc.lp')

    model.solve(solver)

    with open('output.json','w+') as f:
        json.dump(model.toDict(),f,indent=4)

# ===================================================================================
# ============================== Creates a dataframe of results =====================
if __name__ == '__main__':
    run()
    df = pd.DataFrame()
    # Print iterations progress
    def printProgressBar (iteration, total, prefix = '', suffix = '', decimals = 1, length = 100, fill = '█', printEnd = "\r"):
        """
        Call in a loop to create terminal progress bar
        @params:
            iteration   - Required  : current iteration (Int)
            total       - Required  : total iterations (Int)
            prefix      - Optional  : prefix string (Str)
            suffix      - Optional  : suffix string (Str)
            decimals    - Optional  : positive number of decimals in percent complete (Int)
            length      - Optional  : character length of bar (Int)
            fill        - Optional  : bar fill character (Str)
            printEnd    - Optional  : end character (e.g. "\r", "\r\n") (Str)
        """
        percent = ("{0:." + str(decimals) + "f}").format(100 * (iteration / float(total)))
        filledLength = int(length * iteration // total)
        bar = fill * filledLength + '-' * (length - filledLength)
        print(f'\r{prefix} |{bar}| {percent}% {suffix}', end = printEnd)
        # Print New Line on Complete
        if iteration == total: 
            print()

    data:dict = {'Time id': [],
                'Generator Name':[],
                'Generator Id':[],
                'Dispatched Energy':[],
                'Unit Status': [],
                'Ramp Down Rate (MW/h)': [],
                'Ramp Up Rate (MW/h)':[],
                'Max Capacity': [], 
                'Minimum Capacity':[],
                'Demand':[]
                }

    progbar_idx = 0
    for time in range(len(HOURLY_DEMAND)):
        for gen in GENERATORS.index.tolist():
            printProgressBar(progbar_idx,total=len(GEN_UNITS.keys()))
            id = f'{gen}_{time}'
            gen_name            = GENERATORS.iloc[gen]['Plant Name']
            gen_id              = GENERATORS.iloc[gen]['Generator ID']
            generated_energy    = GEN_UNITS[id].value()
            demand              = HOURLY_DEMAND[time]
            nameplate           = float([GENERATORS.iloc[gen]['Nameplate Capacity (MW)']][0])
            min_cap             = float([GENERATORS.iloc[gen]['Minimum Capacity (MW)']][0])
            RD                  = GENERATORS['Ramp Down Rate (MW/h)'].iloc[gen]
            RU                  = GENERATORS['Ramp Up Rate (MW/h)'].iloc[gen]
            U_                  = U[id].value()

            val     = [time,gen_name,gen_id,((generated_energy * (ACCURACY**(-1)))*nameplate),U_,RD,RU,nameplate,min_cap,demand]
            keys    = [i for i in data]
            for i in range(len(val)):
                data[keys[i]].append(val[i])
            progbar_idx +=1

    df = pd.DataFrame(data)
    #df.to_parquet('RESULTS.parquet')
    df.to_csv('RESULTS.csv',index=False)

    HOURLY_DEMAND.to_csv('demand.csv',index = False)

    plt.figure(1)
    plt.plot(HOURLY_DEMAND.tolist())
    plt.show()
    plt.savefig('demand.png')

    u_vals  = [U[i].value() for i in U]
    u_names = [i for i in U]

    v_vals  = [V[i].value() for i in V]
    v_names = [i for i in V]

    w_vals  = [W[i].value() for i in W]
    w_names = [i for i in W]

    d = {'u_name': u_vals,'u':u_names}

    print(pd.DataFrame(d))







